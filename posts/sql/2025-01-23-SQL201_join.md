---
layout: post
category: SQL
tags: ['sql']

date: 2025-01-23
author: Akai Red
title: SQL 201 - JOIN
description: 
    관계형 데이터베이스에서 원하는 데이터를 추출하기 위해 JOIN은 필수적이다.

# image: 
#     https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_760,h_399,r_5,f_auto,q_auto/lrc/20220301_img1
# optimized_image: 
#     https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_380,h_200,r_5,f_auto,q_auto/lrc/20220301_img1

show_thumbnail: true
math: true
published: true
---

## JOIN
JOIN은 서로 다른 테이블의 자료를 하나로 합쳐서 보여주기 위한 명령이다. 관계형 데이터베이스에서 원하는 데이터를 추출하기 위해 JOIN은 필수적이다. 

<!-- 
```sql
CREATE TABLE DEPT (
 DEPTNO              number(10),
 DNAME               VARCHAR2(14),
 LOC                 VARCHAR2(13) 
);

INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH',   'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES',      'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');

CREATE TABLE EMP (
 EMPNO               NUMBER(4) NOT NULL,
 ENAME               VARCHAR2(10),
 JOB                 VARCHAR2(9),
 MGR                 NUMBER(4) ,
 HIREDATE            DATE,
 SAL                 NUMBER(7,2),
 COMM                NUMBER(7,2),
 DEPTNO              NUMBER(2) 
 );

INSERT INTO EMP VALUES (7839,'KING','PRESIDENT',NULL,TO_DATE('1981-11-17','YYYY-MM-DD'),5000,NULL,10);
INSERT INTO EMP VALUES (7698,'BLAKE','MANAGER',7839,TO_DATE('1981-05-01','YYYY-MM-DD'),2850,NULL,30);
INSERT INTO EMP VALUES (7782,'CLARK','MANAGER',7839,TO_DATE('1981-05-09','YYYY-MM-DD'),2450,NULL,10);
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,TO_DATE('1981-04-01','YYYY-MM-DD'),2975,NULL,20);
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN',7698,TO_DATE('1981-09-10','YYYY-MM-DD'),1250,1400,30);
INSERT INTO EMP VALUES (7499,'ALLEN','SALESMAN',7698,TO_DATE('1981-02-11','YYYY-MM-DD'),1600,300,30);
INSERT INTO EMP VALUES (7844,'TURNER','SALESMAN',7698,TO_DATE('1981-08-21','YYYY-MM-DD'),1500,0,30);
INSERT INTO EMP VALUES (7900,'JAMES','CLERK',7698,TO_DATE('1981-12-11','YYYY-MM-DD'),950,NULL,30);
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,TO_DATE('1981-02-23','YYYY-MM-DD'),1250,500,30);
INSERT INTO EMP VALUES (7902,'FORD','ANALYST',7566,TO_DATE('1981-12-11','YYYY-MM-DD'),3000,NULL,20);
INSERT INTO EMP VALUES (7369,'SMITH','CLERK',7902,TO_DATE('1980-12-09','YYYY-MM-DD'),800,NULL,20);
INSERT INTO EMP VALUES (7788,'SCOTT','ANALYST',7566,TO_DATE('1982-12-22','YYYY-MM-DD'),3000,NULL,20);
INSERT INTO EMP VALUES (7876,'ADAMS','CLERK',7788,TO_DATE('1983-01-15','YYYY-MM-DD'),1100,NULL,20);
INSERT INTO EMP VALUES (7934,'MILLER','CLERK',7782,TO_DATE('1982-01-11','YYYY-MM-DD'),1300,NULL,10);
```

`EMP` 테이블에는 사원의 이름과 소속부서코드가 있다. 부서명은 별개의 `DEPT` 테이블에 정리되어 있다. 부서명을 `EMP` 테이블 포함하지 않고 별도의 테이블을 생성하는 장점이 있다. 부서 테이블을 따로 관리하면 데이터 중복을 줄이고 데이터 무결성을 확보하기 유리하다.

| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |
| - | - | - | - | - | - | - | - |
| 7839 | 'KING'   | 'PRESIDENT' | NULL  | '1981-11-17'  | 5000  | NULL  | 10  |
| 7698 | 'BLAKE'  | 'MANAGER'   | 7839  | '1981-05-01'  | 2850  | NULL  | 30  |
| 7782 | 'CLARK'  | 'MANAGER'   | 7839  | '1981-05-09'  | 2450  | NULL  | 10  |
| 7566 | 'JONES'  | 'MANAGER'   | 7839  | '1981-04-01'  | 2975  | NULL  | 20  |
| 7654 | 'MARTIN' | 'SALESMAN'  | 7698  | '1981-09-10'  | 1250  | 1400  | 30  |
| 7499 | 'ALLEN'  | 'SALESMAN'  | 7698  | '1981-02-11'  | 1600  | 300   | 30  |
| 7844 | 'TURNER' | 'SALESMAN'  | 7698  | '1981-08-21'  | 1500  | 0     | 30  |
| 7900 | 'JAMES'  | 'CLERK'     | 7698  | '1981-12-11'  | 950   | NULL  | 30  |
| 7521 | 'WARD'   | 'SALESMAN'  | 7698  | '1981-02-23'  | 1250  | 500   | 30  |
| 7902 | 'FORD'   | 'ANALYST'   | 7566  | '1981-12-11'  | 3000  | NULL  | 20  |
| 7369 | 'SMITH'  | 'CLERK'     | 7902  | '1980-12-09'  | 800   | NULL  | 20  |
| 7788 | 'SCOTT'  | 'ANALYST'   | 7566  | '1982-12-22'  | 3000  | NULL  | 20  |
| 7876 | 'ADAMS'  | 'CLERK'     | 7788  | '1983-01-15'  | 1100  | NULL  | 20  |
| 7934 | 'MILLER' | 'CLERK'     | 7782  | '1982-01-11'  | 1300  | NULL  | 10  |

데이터는 깔끔하게 정리되었지만 특정 사원의 소속부서명을 확인하려면 두 개의 테이블을 비교해서 찾아야하는 불편함이 생겼다. 이런 불편함을 해소하기 위해 JOIN이라는 것이 등장하는데 JOIN은 자동적으로 사원의 소속부서코드를 읽고 해당하는 부서명을 하나의 테이블로 엮어 출력한다. -->


### Inner Join
```sql
SELECT A.컬럼명
     , B.컬럼명
  FROM 원본테이블명 A
 INNER JOIN 참조테이블명 B
    ON A.조인컬럼1 = B.조인컬럼1
   AND A.조인컬럼2 = B.조인컬럼2
;
```
**INNER JOIN**은 특정 컬럼을 기준으로 두 테이블에 공통적으로 포함된 값을 추출한다. 집합적으로는 A와 B의 교집합이다. 그냥 `JOIN`이라고만 쓰면 `INNER JOIN`을 의미한다. INNER JOIN을 그만큼 자주 쓰고 중요하기 때문에 기본값으로 한 것이다. 

기준으로 삼을 컬럼은 `ON EMP.DEPTNO = DEPT.DEPTNO`처럼 명시한다. 결과는 `DEPT` 테이블에 `EMP` 테이블의 정보까지 합쳐져서 나오는데 두 테이블의 자료는 `DEPTNO`가 같은 행끼리 연결되어 있다.

테이블명 뒤에 별명을 따로 지정해준다. 서로 다른 테이블을 연결하는데 이름이 같은 컬럼이 있을 경우 오류가 발생한다. 이럴 경우 테이블명 혹은 별명을 사용해 어느 테이블의 컬럼인지 구체적으로 명시한다. 

조인 컬럼은 두 개 이상 사용할 수도 있다. 잘못된 조인 컬럼을 사용할 경우 조인이 안되거나 데이터 중복이 발생할 수 있다.


### Outer Join
#### Left Outer Join
```sql
SELECT A.컬럼명
     , B.컬럼명
  FROM 원본테이블명 A
  LEFT OUTER JOIN 참조테이블명 B
    ON A.조인컬럼 = B.조인컬럼
;
```
**LEFT OUTER JOIN**은 기준 테이블에 포함된 값은 모두 반환하며 기준컬럼으로 조인이 이루어지지 않을 경우 NULL을 반환한다. 회원 테이블을 주문 테이블과 LEFT OUTER JOIN을 한다면 주문 내역이 없는 회원의 데이터도 남는다. 다만 주문 컬럼에 NULL이 들어갈 뿐이다. INNER JOIN을 사용한다면 주문 내역이 없는 회원의 데이터 자체가 제외된다.

#### Full Outer Join
```sql
SELECT A.컬럼명
     , B.컬럼명
  FROM 원본테이블명 A
  FULL OUTER JOIN 참조테이블명 B
    ON A.조인컬럼 = B.조인컬럼
;
```
**FULL OUTER JOIN**은 기준 테이블의 값도, 조인 테이블의 값도 모두 살린다. 

#### No Right Outer Join
LEFT OUTER JOIN은 `A LEFT JOIN B`의 형태이며 A 테이블에 B 테이블의 자료를 붙인다. 왼쪽에 있는 테이블을 기준으로 자료를 덧붙이기 때문에 LEFT JOIN이라고 한다. 그래서 오른쪽 테이블을 기준으로 자료를 덧붙이는 RIGHT JOIN도 존재한다. 

Oracle이나 MySQL에서는 `RIGHT JOIN` 혹은 `RIGHT OUTER JOIN` 등의 명령어로 RIGHT JOIN을 실행할 수 있다. 그러나 SQLite3, Impala 등 일부 쿼리 프로그램에서는 RIGHT JOIN을 지원하지 않는다. 비슷한 결과를 얻고 싶다면 `B JOIN A`처럼 순서를 바꿔 조인해야 한다.


## JOIN etc
### Multiple Join
```sql
SELECT A.컬럼명
     , B.컬럼명
     , C.컬럼명
  FROM 원본테이블명 A
 INNER JOIN 참조테이블1 B
    ON A.조인컬럼 = B.조인컬럼
 INNER JOIN 참조테이블2 C
    ON A.조인컬럼 = C.조인컬럼    
;
```
3개 이상의 테이블을 조인하는 것도 가능하다. 2개 테이블의 조인과 방법은 동일하다. C테이블을 결합할 때 원본 A 테이블과 결합하는 것도 가능하고, 먼저 결합한 B 테이블과 결합하는 것도 가능하다.


### Cross Join (Cartesian Product)
```sql
-- Cross Join (ANSI)
SELECT A.컬럼명
     , B.컬럼명
  FROM 원본테이블명 A
 CROSS JOIN 참조테이블명 B

-- Cross Join (Oracle)
SELECT A.컬럼명
     , B.컬럼명
  FROM 원본테이블명 A, 참조테이블명 B
```

교차 조인*Cross Join*은 카테시안 곱*Cartesian Product*이라고도 부르며 두 테이블의 모든 가능한 조합을 반환한다. 모든 가능한 조합을 반환하기 때문에 조인컬럼을 따로 지정할 필요가 없다. 사이즈 $m, n$의 테이블을 교차 조인하게 되면 $m \times n$ 사이즈의 결과 테이블이 생성된다. 

교차 조인을 실제로 사용할 경우는 많지 않고 실수로 조인하는 경우가 많다. 오라클 조인 시 조인 조건을 명시하지 않으면 교차 조인을 수행하며 이러한 점을 이유로 ANSI 조인이 더 권장된다.


### Self Join
```sql
-- Self Join (ANSI)
SELECT A.컬럼명
     , B.컬럼명
  FROM 원본테이블명 A
 INNER JOIN 원본테이블명 B
    ON A.조인컬럼 = B.조인컬럼
```
셀프 조인*Self Join*은 자기 자신을 대상으로 조인을 수행하는 것을 말한다. 따로 분류하지 않는 경우도 많다. 동일한 테이블이지만 별칭*alias*을 다르게 설정하는 것이 중요하다.  


## References
* [Source: Visual-Representation-of-SQL-Joins](http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins)
