---
layout: post
category: SQL
tags: ['sql']

date: 2023-10-04
author: Akai Red
title: SQL 101 - Null
description: 
    결측값 처리는 데이터 분석에서 중요한 부분이다. SQL에도 결측값을 찾는 다양한 방법이 존재한다.

image: 
    https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_760,h_399,r_5,f_auto,q_auto/lrc/20220301_img1
optimized_image: 
    https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_380,h_200,r_5,f_auto,q_auto/lrc/20220301_img1

show_thumbnail: true
math: true
published: true
---

## 기본적인 결측값 처리
### IS NULL
```sql
-- NULL 값 전체 확인
SELECT * FROM 테이블명
 WHERE 컬럼명 IS NULL
    -- OR 컬럼명 = NULL  (X)
    -- OR 컬럼명 = ''    (X)
 ;

-- 특정 컬럼 중 NULL을 제외한 값 확인
SELECT COUNT(*)          -- NULL값 포함
      ,COUNT(컬럼명)      -- NULL값 제외
  FROM 테이블명;
```  
SQL에서 결측값은 `NULL` 혹은 `''(빈 문자열)`로 나타낸다. `''`는 `NULL`과 동일하게 사용된다.

`NULL`을 필터링하기 위해서 `IS NULL`을 사용한다. `=` 비교 연산자를 직접 사용할 수는 없다. `NULL`이 아닌 값을 필터링하기 위해서는 `IS NOT NULL`을 사용하면 된다.

특정 컬럼의 NULL 개수를 확인하기 위해 `SELECT`절에서 `COUNT`를 사용할 수 있다. `COUNT(*)`는 NULL을 포함한 전체 데이터 개수를 반환하고 `COUNT(컬럼명)`은 특정 컬럼의 NULL을 제외한 데이터 개수를 반환한다.

아쉽게도 파이썬의 `df.isna()`처럼 전체 데이터의 NULL 값을 한 번에 확인할 수 있는 방법은 내가 알기로는 없다. 


### NVL, IFNULL  
```sql 
SELECT NVL('Lorem Ipsum', '없음')     -- 'Lorem Ipsum' 출력 (Oracle) 
      ,NVL(NULL, '없음')              -- '없음' 출력 (Oracle) 
      
      ,IFNULL('Lorem Ipsum', '없음')  -- 'Lorem Ipsum' 출력 (MySQL 등) 
      ,IFNULL(NULL, '없음')           -- '없음' 출력 (MySQL 등)

      ,ISNULL('Lorem Ipsum', '없음')  -- 'Lorem Ipsum' 출력 (MSSQL 등) 
      ,ISNULL(NULL, '없음')           -- '없음' 출력 (MSSQL 등)
       
  FROM EMP;
```  
오라클에서 `NVL(A,B)`는 `A`가 `NULL`이면 `B`를 반환하고, `NULL`이 아닐 경우 `A`를 그대로 반환한다. MySQL 등에서는 `IFNULL(A,B)`이, MSSQL 등에서는 `ISNULL(A,B)`이 동일한 역할을 수행한다. 나는 Oracle을 주로 써서 `NVL`에 익숙해졌지만 `IFNULL`이나 `ISNULL`쪽이 `NVL` 보다 직관적 네이밍이라고 생각한다.


### NULLIF  
```sql
SELECT NULLIF(JOB, 'MANAGER')
  FROM 테이블명;
```  
`NULLIF(A,B)`는 `A`가 `B`와 일치하면 `NULL`을 반환하고, 일치하지 않으면 `A`를 그대로 반환한다. 위의 코드에서는 `'MANAGER'` 직업만 `NULL`로 바꿔주었다. 데이터에 굳이 `NULL`을 새로 만드는 것보다는 별도로 라벨링 해주는 것이 좋기 때문에 자주 사용하지는 않는다.


### COALESCE
```sql
SELECT COALESCE(컬럼1, 컬럼2, 컬럼3)
  FROM 테이블명;
```
`COALESCE(A,B,C, ...)`는 다른 Null 함수에 비해 이질적이다. 이 함수는 입력한 칼럼 중 `NULL`이 아닌 가장 먼저 입력한 값을 돌려준다. 아래 표에서 왼쪽 행렬에 `COALESCE(A,B,C)` 명령을 적용하면 오른쪽과 같은 결과가 나온다.

|  A |  B |  C | | COALESCE(A,B,C)|
|  - |  - |  - |-|  - |
|  2 |  5 | 12 | |  2 |
|    |  1 |  3 | |  1 |
|    |    | 15 | | 15 |

후보가 있다고 생각하면 좋다. 기본적으로 `A`를 출력하지만 `NULL`일 경우 출력할 후보 `B`, `C`를 미리 지정해놓는 것이다. 


## 보다 복잡한 결측값 다루기
### 예시 테이블

| empno | ename | job       | mgr  | hiredate   | sal     | comm    | deptno |
| -     | -     | -         | -    | -          | -       | -       | -  |
| 7369  | SMITH | CLERK     | 7902 | 1993-06-13 | 800.00  | 0.00    | 20 |
| 7499  | ALLEN | SALESMAN  | 7698 | 1998-08-15 | 1600.00 | 300.00  | 30 |
| 7521  | WARD  | SALESMAN  | 7698 | 1996-03-26 | 1250.00 | 500.00  | 30 |
| 7566  | JONES | MANAGER   | 7839 | 1995-10-31 | 2975.00 |         | 20 |
| 7698  | BLAKE | MANAGER   | 7839 | 1992-06-11 | 2850.00 |         | 30 |
| 7782  | CLARK | MANAGER   | 7839 | 1993-05-14 | 2450.00 |         | 10 |
| 7788  | SCOTT | ANALYST   | 7566 | 1996-03-05 | 3000.00 |         | 20 |
| 7839  | KING  | PRESIDENT |      | 1990-06-09 | 5000.00 | 0.00    | 10 |
| 7844  | TURNER| SALESMAN  | 7698 | 1995-06-04 | 1500.00 | 0.00    | 30 |
| 7876  | ADAMS | CLERK     | 7788 | 1999-06-04 | 1100.00 |         | 20 |
| 7900  | JAMES | CLERK     | 7698 | 2000-06-23 | 950.00  |         | 30 |
| 7934  | MILLER| CLERK     | 7782 | 2000-01-21 | 1300.00 |         | 10 |
| 7902  | FORD  | ANALYST   | 7566 | 1997-12-05 | 3000.00 |         | 20 |
| 7654  | MARTIN| SALESMAN  | 7698 | 1998-12-05 | 1250.00 | 1400.00 | 30 |

### 집계 함수
```sql
-- NULL 연산의 결과는 NULL
-- 연봉과 보너스를 합친 금액을 구하고 싶을 경우
SELECT SAL + COMM FROM EMP;         -- X
SELECT SAL + NVL(COMM,0) FROM EMP;  -- O
```
산술연산자에 `NULL`이 들어가면 제대로 된 계산이 되지 않는다. 문제는 아예 ERROR가 떠버리는게 아니라 Oracle에서는 자체적으로 결과값을 NULL로 만들어버린다. 

NULL이 포함된 컬럼을 연산할 경우 `NVL`을 사용해서 NULL을 0으로 바꿔줘야 원하는 결과를 얻을 수 있다.연봉과 보너스를 합친 총 연봉을 구하고 싶을 때 첫번째 쿼리처럼 작성하면 대부분의 직원의 총 연봉이 NULL이 되어버린다. 

```sql
-- NULL이 존재할 경우 집계함수는 자동적으로 NULL을 제외
SELECT AVG(COMM)                    -- 550 
     , SUM(COMM) / COUNT(*)         -- 157.14
  FROM EMP;
```
집계 함수는 NULL을 자동적으로 결과에서 제외한다. 직원 1인당 받은 커미션 금액`COMM`을 구하기 위해 `AVG(COMM)`을 사용한다면 NULL을 제외한 평균을 보여준다. 직원 1인당 받은 커미션이 아니라 커미션을 받은 직원들의 평균 커미션 금액이다. 전자는 `SUM(COMM) / COUNT(*)`로 구한다.

분석의 목적에 따라 전자가 필요할 수도 있고, 후자가 필요할 수도 있다. NULL로 인한 차이점을 알고 잘 나눠서 사용해야 한다. 전자가 필요해도 WHERE절 등에서 따로 NULL 필터 처리를 한 다음에 집계하는 것이 좋다.

### CASE WHEN을 사용할 경우
```sql
-- ELSE 처리를 해주지 않으면 전부 NULL이 되어버린다.
SELECT ENAME
     , CASE WHEN JOB = 'SALESMAN' THEN 1000
            WHEN JOB = 'ANALYST'  THEN 2000
            END AS EXTRA
  FROM EMP;
```
`NULL`은 초기 데이터 뿐 아니라 `CASE WHEN` 등을 사용할 때도 생긴다. 만약 영업사원과 애널리스트에게 각각 1000, 2000의 엑스트라 보너스를 준다고 하자. 엑스트라 보너스를 받는 사원과 그 금액은 위와 같이 `CASE WHEN`을 써서 확인할 수 있다. 

`CASE WHEN` 사용 시 `ELSE` 조건을 작성하지 않아도 쿼리는 돌아간다. `ELSE`에 해당하는 값이 모두 NULL로 처리될 뿐이다. 의도치 않은 NULL 데이터 생성은 좋지 않으므로 `CASE WHEN` 사용 시 `ELSE` 조건을 꼭 명시해주자.

<!-- ### SUM(NVL()) vs NVL(SUM())
```sql
``` -->
