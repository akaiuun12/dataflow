---
layout: post
category: SQL
tags: ['sql']

date: 2023-10-02
author: Akai Red
title: SQL 101 - Order by & Sort Operations
description: 
    ORDER BY를 사용한 결과 정렬 방법과 그 뒤에 숨겨진 원리를 알아보자.

image: 
    https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_760,h_399,r_5,f_auto,q_auto/lrc/20220301_img1
optimized_image: 
    https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_380,h_200,r_5,f_auto,q_auto/lrc/20220301_img1

show_thumbnail: true
math: true
published: true
---

## 0. Sort Basic  
```sql
SELECT 컬럼명1, 컬럼명2, 컬럼명3 
  FROM 테이블
 ORDER BY 컬럼명1, 컬럼명2 DESC, 컬럼명3
;
```
`ORDER BY`를 사용하면 데이터를 원하는 순서대로 정렬할 수 있다. 위의 쿼리는 컬럼1을 기준으로 오름차순으로 정렬하되 동점이 있을 경우 컬럼2 내림차순, 컬럼3 오름차순 순으로 정렬하라는 의미다. `ORDER BY` 절은 쿼리의 제일 하단에 사용한다.

> 일반적인 수준에서는 위의 내용만으로 충분하며 아래의 내용은 SQL 튜닝과 관련된 내용이다.


## 1. Sort Aggregate  
```sql
SELECT SUM(SAL), MAX(SAL), MIN(SAL), AVG(SAL)
  FROM EMP;
```
**Sort Aggregate**는 전체 로우 대상으로 집계할 때 나타난다. 실제로 데이터를 정렬하지는 않지만 Sort Area를 사용하기 때문에 Sort Aggregate라고 부른다. 집계 함수의 작동 원리는 간단하다. 준비물은 Sort Area 혹은 메모지 한 장이다.

    1. Sort Area(메모지)에 SUM, MAX, MIN, COUNT 변수를 하나씩 할당한다.
    2. 첫번째 행 값을 SUM, MAX, MIN 변수에 저장하고 COUNT에는 1을 저장한다.
    3. 행을 하나씩 읽어들이면서 SUM, COUNT에는 각각 값과 1을 추가하고 MAX, MIN은 갱신한다.
       (AVG는 모든 행을 읽어들인 후 SUM을 COUNT로 나누면 된다.) 


## 2. Sort Order By  
```sql
SELECT * FROM EMP ORDER BY SAL DESC;
```
`Sort Order By`는 데이터를 정렬할 때 나타난다. 자세한 원리는 설명하기 어렵지만 전체 데이터를 **정렬하는 것은 메모리 집약적이고 CPU 집약적**이라는 사실을 알 필요가 있다. 따라서 꼭 필요한 경우에만 `ORDER BY` 연산을 사용하는 것이 좋다.


## 3. Sort Group By & Hash Group By  
```sql
SELECT DEPTNO, SUM(SAL), MAX(SAL), MIN(SAL), AVG(SAL)
  FROM EMP
 GROUP BY DEPTNO;
```
`Hash Group By`는 1에서 설명했던 집계 연산을 `GROUP BY`를 사용해서 그룹별로 수행할 때 나타난다. 그룹별 수행이라고는 해도 크게 달라진 것은 없으며 메모지의 개수를 그룹 수만큼 늘리면 된다. 전체 그룹 수를 알면 미리 맞춰 메모지를 준비하는 것이 가능하다. 그러나 실제 데이터에서는 전체 그룹 수를 알지 못한다. 

전체 그룹 수를 모른다면 새로운 그룹이 나올 때마다 메모지를 추가하면 된다. `Sort Group By`는 메모지를 정렬된 연결 리스트로 `Hash Group By`는 해시 함수를 사용해서 만든다는 것이 차이점이다. 그 뒤는 메모지 각각에 대해 Sort Aggregate를 동일하게 수행해준다. 


## 4. Sort Unique & Hash Unique  
```sql
SELECT DISTINCT DEPTNO FROM EMP;
```
유일성을 확인하는 과정에서도 정렬이 발생한다. 유일성은 확인하는 경우는 `DISTINCT`를 사용하거나 집합 연산자, Subquery Unnesting을 하는 경우 등이 있다. 이 때도 `Sort Unique`와 `Hash Unique` 두 가지 방법이 있는데 각각 정렬된 연결 리스트과 해쉬 함수를 사용하는 차이점만 있을 뿐 원리는 동일하다.

오라클 10gR2버전부터 `ORDER BY`를 명시하지 않으면 `Hash Group By`와 `Hash Unique`를 기본으로 사용한다. 또한 `Sort Group By`와 `Sort Unique`를 사용하는 경우에도 `ORDER BY`를 명시해야 결과값을 정렬하여 출력한다.


## 5. etc  
위에 언급한 사례 외에 윈도우 함수를 사용할 때는 `Window Sort`가 발생하고 소트 머지 조인을 사용할 때는 `Sort Join`가 발생한다. 이 사례는 많지 않기 때문에 넘어가며 필요할 경우 추후 설명하도록 한다.


## Should I use order by or not?  
앞에서 정렬은 메모리 집약적이고 CPU 집약적인 과정이라 SQL 최적화 측면에서 정렬을 가급적 사용하지 않는 것이 좋다고 했다. 그러나 실제 데이터 분석을 수행할 때 **분석의 중간 단계에서 성능을 어느 정도 포기하고 데이터를 정렬하는 것이 도움이 될 때가 있다**. 

예를 들어 중간 데이터를 정렬해서 확인하면 조인 오류로 인한 중복 데이터를 쉽게 잡아낼 수 있다. 쿼리 성능을 우선할 것인지 아니면 이해를 우선할 것인지는 분석가가 상황에 맞춰 선택해야 한다.

## References  
* [DBian 도서](http://dbian.co.kr/sub/sub03_01.php)
* [친절한 SQL 튜닝](https://search.shopping.naver.com/book/catalog/32442690254)
