---
title: SQL 201 - CTE and Subquery
description: CTE(Common Table Expression)와 서브쿼리를 사용한 복잡한 쿼리 작성 방법과 성능 비교.
image: https://res.cloudinary.com/dhchweuhy/image/upload/c_fill,w_760,h_399,r_5,f_auto,q_auto/lrc/20220301_img1
date: 2025-02-09
author: Akai Red
category: SQL
tags: ['sql']
published: false
---

## CTE (WITH)
```sql
WITH t1 AS(
  SELECT customer_id, customer_name
    FROM customers
   WHERE sample_id != '42'
)
SELECT customer_name
  FROM t1
 WHERE ROWNUM < 10
;
```
CREATE TABLE을 사용하지 않고 임시 테이블을 만들 수 있다. `WITH`절을 사용한 **CTE(Common Table Expression)** 형식이다. 위의 쿼리에서 t1이라는 임시 테이블을 만들고, 아래 SELECT 절에서 사용한다. 밑에 설명할 서브쿼리와 동일한 역할을 하는데 가독성 측면에서 CTE를 사용하는 것이 낫다.

## Subquery
```sql
SELECT customer_name
  FROM (SELECT customer_id, customer_name
          FROM customers
         WHERE sample_id != '42')
 WHERE ROWNUM < 10
;
```
`SELECT`절 안에 또 다른 `SELECT`절을 사용하는 것을 서브쿼리*Subquery*라고 부른다. CTE 대신 서브쿼리를 사용해서 임시테이블을 생성할 수도 있다. 2002년에 Oracle 9.2버전이 출시되기 이전에는 `WITH`절이 없었다. 그래서 아주 옛날 쿼리에는 서브쿼리를 이중, 삼중으로 사용하는 경우가 많았다. 

짧은 쿼리는 상관 없지만 쿼리가 길어지면 서브쿼리는 가독성이 좋지 않으므로 `WITH`을 사용하자.

## Recursive CTE
```sql
WITH CTE (컬럼명1, 컬럼명2) AS (
    -- A
    SELECT 컬럼명1, 컬럼명2 
      FROM 원본테이블명
     WHERE 재귀시작조건
     
     UNION ALL
    
    -- B
    SELECT 컬럼명1, 컬럼명2 
      FROM CTE
     WHERE 재귀지속조건
)
    SELECT * 
      FROM CTE
```
재귀적 CTE*Recursive CTE*는 자기 참조 방식으로 반복문을 일부 구현한다. 위 쿼리의 A파트에서 시작해서 재귀지속조건을 달성하는 한 B파트를 반복해서 더한다. 재귀의 특징상 무한루프에 빠지지 않게 만드는 것이 중요하다.

### Recursive CTE Example 1

> 1부터 5까지의 값을 출력하라.

```sql
WITH CTE (num) AS (
    -- A
    SELECT 1 AS num 
      FROM Dual

     UNION ALL
    
    -- B
    SELECT num + 1
      FROM CTE
     WHERE num < 5
)
    SELECT * 
      FROM CTE
```

재귀적 CTE를 사용하면 간단한 반복문을 구현할 수 있다. 1부터 5까지를 출력하라는 건 프로그래밍 언어로는 간단하지만, SQL로는 생각보다 쉽지 않다. 재귀적 CTE로 A파트에서 기저조건인 1을 설정하고, 그 뒤 B파트에서 `num=5`가 될 때까지 `num`에 1을 더해서 합친다. 결과는 (모두 알다시피) 아래와 같다.

| num |
| - |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |

### Recursive CTE Example 2

> 10번째까지의 피보나치 수를 출력하라.

```sql
WITH CTE (n, a, b, fib_n) AS (
  -- A
  SELECT 1 AS n
       , 0 AS a
       , 1 AS b
       , 1 AS fib_n
    FROM Dual
  
   UNION ALL

  -- B
  SELECT n+1      AS n
       , b        AS a
       , fib_n    AS b
       , b+fib_n  AS fib_n
    FROM CTE
   WHERE n < 10
)
  SELECT *
    FROM CTE
;
```

피보나치 수열은 0, 1로 시작해서 직전 2개 값의 합이 수열의 다음 항이 되는 간단한 구조의 수열이다. 재귀적 CTE를 연습하기 좋은 문제다. 직전 로우의 `b`, `fib_n` 값이 다음 로우의 `a`, `b`가 되는 것이 포인트다.

| n | a | b | fib_n |
| 

### Recursive CTE Example 3

> 사장PRESIDENT의 RANK를 1로 하고, 아래 단계로 내려갈수록 RANK를 1 추가한다.
> 사장부터 시작해서 직속 부하를 RANK별로 순서대로 출력하라. 

```sql
WITH Cte (empno, ename, job, mgr, rank) AS (
  SELECT empno, ename, job, mgr
       , 1 AS rank
    FROM Emp
   WHERE job = 'PRESIDENT'

   UNION ALL
  
  SELECT A.empno, A.ename, A.job, A.mgr
       , A.rank + 1
    FROM Emp A
    JOIN Cte B
      ON A.mgr = B.empno
)
  SELECT *
    FROM Cte
;
```

조금 더 실무적인 예제로 재귀적 CTE의 효과적 사용을 알아보자. 최상위 권한자인 사장에서 시작하여 `empno=mgr`로 연결된 부하 직원을 권한 순으로 출력하는 것이 목적이다. 

권한은 `JOB`으로 구분할 수 없다. 동일한 `CLERK`이지만 `JAMES`는 `MANAGER`의 감독을 직접 받고, `SMITH`는 `ANALYST`의 감독을 받는다. 둘의 권한 위계는 차이가 난다.

`WHERE` 조건을 통해 시작테이블을 사장 데이터로 한정하고, 꾸준히 `A.mgr = B.empno`를 사용해 조인하면 상위 권한자에서 하위 권한자를 출력할 수 있다. 이렇듯 재귀지속 조건은 반드시 `WHERE`절에 명시할 필요는 없으며 재귀적 CTE에서 조인을 사용할수도 있다.

| EMPNO | ENAME | JOB | MGR | RANK |
| - | - | - | - | - |
| 7839 | KING   | PRESIDENT | NULL  | 1  |
| 7566 | JONES  | MANAGER   | 7839  | 2  |
| 7698 | BLAKE  | MANAGER   | 7839  | 2  |
| 7782 | CLARK  | MANAGER   | 7839  | 2  |
| 7499 | ALLEN  | SALESMAN  | 7698  | 3  |
| 7521 | WARD   | SALESMAN  | 7698  | 3  |
| 7654 | MARTIN | SALESMAN  | 7698  | 3  |
| 7788 | SCOTT  | ANALYST   | 7566  | 3  |
| 7844 | TURNER | SALESMAN  | 7698  | 3  |
| 7900 | JAMES  | CLERK     | 7698  | 3  |
| 7902 | FORD   | ANALYST   | 7566  | 3  |
| 7934 | MILLER | CLERK     | 7782  | 3  |
| 7369 | SMITH  | CLERK     | 7902  | 4  |
| 7876 | ADAMS  | CLERK     | 7788  | 4  |


```
ORA-32044 설명: 순환 WITH 질의를 실행하는 중 주기가 감지되었습니다.
```
```
ORA-32038 설명: WITH 절의 열 이름 수가 선택 목록의 요소 수와 일치하지 않습니다.
```


## References
* []()
